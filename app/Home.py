import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import warnings
import os
import sys
import smtplib
from email.message import EmailMessage
from pathlib import Path
warnings.filterwarnings('ignore')

# Import authentication
import auth

# Add parent directory to path to import the forecast function
sys.path.append(str(Path(__file__).parent.parent))
from pipeline.operational import automated_operational_forecast

# Page configuration
st.set_page_config(
    page_title="Energy Ops Forecast | Executive Dashboard",
    page_icon="‚ö°",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for professional styling
st.markdown("""
<style>
    .main > div {
        padding-top: 2rem;
    }

    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1.5rem;
        border-radius: 12px;
        color: white;
        margin: 0.5rem 0;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .metric-value {
        font-size: 2.5rem;
        font-weight: bold;
        margin: 0;
    }

    .metric-label {
        font-size: 0.9rem;
        opacity: 0.9;
        margin: 0;
    }

    .kpi-container {
        background: white;
        padding: 1.5rem;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border-left: 4px solid #667eea;
    }

    .sidebar .sidebar-content {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }

    .stAlert {
        border-radius: 8px;
    }

    h1 {
        color: #2c3e50;
        font-weight: 700;
        margin-bottom: 2rem;
    }

    h2, h3 {
        color: #34495e;
        font-weight: 600;
    }
</style>
""", unsafe_allow_html=True)

def get_secret(key, default=None):
    """Get secret from Streamlit secrets first, then environment fallback."""
    try:
        return st.secrets[key]
    except Exception:
        return os.getenv(key, default)

def get_smtp_config():
    """Get SMTP configuration from Streamlit secrets or environment variables."""
    smtp_host = get_secret("SMTP_HOST")
    smtp_port = int(get_secret("SMTP_PORT", "587"))
    smtp_user = get_secret("SMTP_USER")
    smtp_pass = get_secret("SMTP_PASS")
    smtp_use_tls = str(get_secret("SMTP_USE_TLS", "true")).lower() == "true"

    return smtp_host, smtp_port, smtp_user, smtp_pass, smtp_use_tls

def send_forecast_email(csv_files, recipient_email="osmanorka@gmail.com"):
    """Send forecast CSV files via email using SMTP."""
    try:
        # Get SMTP configuration
        smtp_host, smtp_port, smtp_user, smtp_pass, smtp_use_tls = get_smtp_config()

        if not all([smtp_host, smtp_user, smtp_pass]):
            return False, "SMTP configuration missing. Please set SMTP_HOST, SMTP_USER, and SMTP_PASS in Streamlit secrets or environment variables."

        # Create email message
        msg = EmailMessage()
        msg['Subject'] = f'Energy Ops Forecast - {datetime.now().strftime("%Y-%m-%d %H:%M")}'
        msg['From'] = smtp_user
        msg['To'] = recipient_email

        # Email body
        body = f"""
Energy Operations Forecast Report
Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

This email contains the latest energy forecast outputs:

üìä Attachments:
‚Ä¢ forecast_baseline.csv - Base case operational forecast
‚Ä¢ forecast_scenario_shock.csv - Extreme scenario forecast
‚Ä¢ forecast_scenario_delta.csv - Impact analysis (shock - baseline)

Files are ready for Power BI consumption and further analysis.

---
Generated by Energy Ops Forecast Dashboard
"""
        msg.set_content(body)

        # Attach CSV files
        for file_path in csv_files:
            if os.path.exists(file_path):
                with open(file_path, 'rb') as f:
                    file_data = f.read()
                    file_name = os.path.basename(file_path)
                    msg.add_attachment(file_data, maintype='text', subtype='csv', filename=file_name)

        # Send email using proper SMTP sequence
        server = smtplib.SMTP(smtp_host, smtp_port)
        try:
            server.ehlo()
            if smtp_use_tls:
                server.starttls()
                server.ehlo()
            server.login(smtp_user, smtp_pass)
            server.send_message(msg)
            return True, f"Email sent successfully to {recipient_email}"
        finally:
            server.quit()

    except smtplib.SMTPException as e:
        return False, f"SMTP error: {str(e)}"
    except Exception as e:
        return False, f"Failed to send email: {str(e)}"

def run_forecast_and_preview():
    """Run forecast and show preview of results."""
    try:
        # Run the forecast
        success, message = automated_operational_forecast(
            input_file='../fact_energy_market.parquet',
            output_dir='../data'
        )

        if not success:
            return False, message, None

        # Load the generated data for preview
        base = pd.read_csv("../data/forecast_baseline.csv", parse_dates=["datetime"])
        shock = pd.read_csv("../data/forecast_scenario_shock.csv", parse_dates=["datetime"])
        delta = pd.read_csv("../data/forecast_scenario_delta.csv", parse_dates=["datetime"])

        # Create preview summary with raw numeric values
        preview_data = {
            'Baseline': {
                'Records': len(base),
                'Avg Price ($/MWh)': round(base['forecast_price'].mean(), 2),
                'Avg Demand (MW)': int(base['forecast_demand'].mean()),
                'Date Range': f"{base['datetime'].min().date()} to {base['datetime'].max().date()}"
            },
            'Shock Scenario': {
                'Records': len(shock),
                'Avg Price ($/MWh)': round(shock['forecast_price'].mean(), 2),
                'Avg Demand (MW)': int(shock['forecast_demand'].mean()),
                'Price Impact (%)': round(((shock['forecast_price'].mean() / base['forecast_price'].mean() - 1) * 100), 1)
            },
            'Delta Analysis': {
                'Records': len(delta),
                'Max Price Delta ($/MWh)': round(delta['delta_price'].max(), 2),
                'Min Price Delta ($/MWh)': round(delta['delta_price'].min(), 2),
                'Avg Price Delta ($/MWh)': round(delta['delta_price'].mean(), 2)
            }
        }

        return True, "Forecast generated successfully", preview_data

    except Exception as e:
        return False, f"Forecast failed: {str(e)}", None

@st.cache_data
def load_forecast_data():
    """Load all forecast data with error handling."""
    try:
        base = pd.read_csv("../data/forecast_baseline.csv", parse_dates=["datetime"])
        shock = pd.read_csv("../data/forecast_scenario_shock.csv", parse_dates=["datetime"])
        delta = pd.read_csv("../data/forecast_scenario_delta.csv", parse_dates=["datetime"])

        # Standardize column names
        for df in [base, shock, delta]:
            if "region" in df.columns:
                df["region"] = df["region"].astype(str)

        return base, shock, delta
    except FileNotFoundError:
        st.error("‚ö†Ô∏è Forecast data not found. Please run the automation pipeline first.")
        st.info("Run: `python run_forecast.py` to generate the required CSV files.")
        return None, None, None

def create_kpi_card(value, label, format_str="{:,.2f}", icon="üìä", delta=None):
    """Create a beautiful KPI card."""
    formatted_value = format_str.format(value) if pd.notna(value) else "‚Äî"

    delta_html = ""
    if delta is not None:
        delta_color = "green" if delta > 0 else "red" if delta < 0 else "gray"
        delta_symbol = "‚Üó" if delta > 0 else "‚Üò" if delta < 0 else "‚Üí"
        delta_html = f'<p style="margin: 0; color: {delta_color}; font-size: 0.8rem;">{delta_symbol} {delta:+.1f}%</p>'

    st.markdown(f"""
    <div class="kpi-container">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <p class="metric-label">{icon} {label}</p>
                <p class="metric-value" style="color: #2c3e50;">{formatted_value}</p>
                {delta_html}
            </div>
        </div>
    </div>
    """, unsafe_allow_html=True)

def create_executive_summary_chart(base_df, shock_df):
    """Create executive summary visualization."""
    # Aggregate data by day for overview
    base_daily = base_df.groupby(base_df['datetime'].dt.date).agg({
        'forecast_price': 'mean',
        'forecast_demand': 'mean'
    }).reset_index()

    shock_daily = shock_df.groupby(shock_df['datetime'].dt.date).agg({
        'forecast_price': 'mean',
        'forecast_demand': 'mean'
    }).reset_index()

    # Create subplot
    fig = make_subplots(
        rows=2, cols=1,
        subplot_titles=('üìà Average Daily Price Forecast', '‚ö° Average Daily Demand Forecast'),
        vertical_spacing=0.12,
        specs=[[{"secondary_y": False}], [{"secondary_y": False}]]
    )

    # Price chart
    fig.add_trace(
        go.Scatter(
            x=base_daily['datetime'],
            y=base_daily['forecast_price'],
            name='Baseline Price',
            line=dict(color='#3498db', width=3),
            fill='tonexty'
        ),
        row=1, col=1
    )

    fig.add_trace(
        go.Scatter(
            x=shock_daily['datetime'],
            y=shock_daily['forecast_price'],
            name='Shock Scenario Price',
            line=dict(color='#e74c3c', width=3, dash='dash'),
        ),
        row=1, col=1
    )

    # Demand chart
    fig.add_trace(
        go.Scatter(
            x=base_daily['datetime'],
            y=base_daily['forecast_demand'],
            name='Baseline Demand',
            line=dict(color='#2ecc71', width=3),
            fill='tonexty'
        ),
        row=2, col=1
    )

    fig.add_trace(
        go.Scatter(
            x=shock_daily['datetime'],
            y=shock_daily['forecast_demand'],
            name='Shock Scenario Demand',
            line=dict(color='#f39c12', width=3, dash='dash'),
        ),
        row=2, col=1
    )

    fig.update_layout(
        height=600,
        showlegend=True,
        template="plotly_white",
        title_text="üìä Executive Summary - 7-Day Forecast Overview",
        title_x=0.5,
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )

    fig.update_xaxes(title_text="Date", row=2, col=1)
    fig.update_yaxes(title_text="Price ($/MWh)", row=1, col=1)
    fig.update_yaxes(title_text="Demand (MW)", row=2, col=1)

    return fig

# Main dashboard
def main():
    # Require authentication
    if not auth.require_login():
        st.stop()

    # Header
    st.markdown("""
    # ‚ö° Energy Operations Forecast
    ## Executive Dashboard - Real-time Market Intelligence
    """)

    # Run Forecast + Send Outputs via Email Section
    st.markdown("### üöÄ Run Forecast + Send Outputs via Email")

    col1, col2, col3 = st.columns([2, 1, 1])

    with col1:
        st.markdown("""
        **Generate fresh forecasts and email results automatically:**
        - Runs automated_operational_forecast with 7-day horizon
        - Generates 3 CSV files (baseline, shock, delta)
        - Sends files as email attachments to osmanorka@gmail.com
        - Shows preview of results in dashboard
        """)

    with col2:
        # SMTP Configuration Status
        smtp_host, smtp_port, smtp_user, smtp_pass, smtp_use_tls = get_smtp_config()
        smtp_configured = all([smtp_host, smtp_user, smtp_pass])

        if smtp_configured:
            st.success("üìß SMTP Configured")
            st.caption(f"Host: {smtp_host}")
        else:
            st.warning("‚ö†Ô∏è SMTP Not Configured")
            st.caption("Set SMTP settings in Streamlit secrets")

    with col3:
        # Run Forecast Button
        if st.button("üéØ Run Forecast & Email", type="primary", use_container_width=True):
            with st.spinner("üîÑ Running forecast..."):
                # Run forecast
                forecast_success, forecast_message, preview_data = run_forecast_and_preview()

                if forecast_success:
                    st.success(f"‚úÖ {forecast_message}")

                    # Show preview
                    if preview_data:
                        st.markdown("#### üìä Forecast Preview")
                        st.dataframe(preview_data, use_container_width=True)

                    # Send email if SMTP is configured
                    if smtp_configured:
                        with st.spinner("üìß Sending email..."):
                            csv_files = [
                                "../data/forecast_baseline.csv",
                                "../data/forecast_scenario_shock.csv",
                                "../data/forecast_scenario_delta.csv"
                            ]
                            email_success, email_message = send_forecast_email(csv_files)

                            if email_success:
                                st.success(f"üìß {email_message}")
                            else:
                                st.error(f"‚ùå {email_message}")
                    else:
                        st.warning("üìß Email not sent - SMTP configuration missing")

                    # Clear cached data to reload new forecast
                    load_forecast_data.clear()

                else:
                    st.error(f"‚ùå {forecast_message}")

    st.markdown("---")

    # Load data
    base_df, shock_df, delta_df = load_forecast_data()

    if base_df is None:
        return

    # Sidebar filters
    st.sidebar.markdown("## üéõÔ∏è Controls")

    # Region selector
    regions = sorted(base_df["region"].unique())
    selected_region = st.sidebar.selectbox("üåç Region", regions, index=0)

    # Date range
    min_date = base_df["datetime"].min().date()
    max_date = base_df["datetime"].max().date()

    date_range = st.sidebar.date_input(
        "üìÖ Forecast Period",
        value=[min_date, max_date],
        min_value=min_date,
        max_value=max_date
    )

    if isinstance(date_range, tuple) and len(date_range) == 2:
        start_date, end_date = date_range
    else:
        start_date = end_date = date_range

    # Filter data
    mask = (
        (base_df["region"] == selected_region) &
        (base_df["datetime"].dt.date >= start_date) &
        (base_df["datetime"].dt.date <= end_date)
    )

    base_filtered = base_df[mask].copy()
    shock_filtered = shock_df[mask].copy()
    delta_filtered = delta_df[
        (delta_df["region"] == selected_region) &
        (delta_df["datetime"].dt.date >= start_date) &
        (delta_df["datetime"].dt.date <= end_date)
    ].copy()

    # Key Metrics Row
    st.markdown("### üìä Key Performance Indicators")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        avg_base_price = base_filtered["forecast_price"].mean()
        price_change = ((shock_filtered["forecast_price"].mean() / avg_base_price - 1) * 100) if avg_base_price > 0 else 0
        create_kpi_card(
            avg_base_price,
            "Average Price (Baseline)",
            "${:,.2f}/MWh",
            "üí∞",
            price_change
        )

    with col2:
        avg_base_demand = base_filtered["forecast_demand"].mean()
        demand_change = ((shock_filtered["forecast_demand"].mean() / avg_base_demand - 1) * 100) if avg_base_demand > 0 else 0
        create_kpi_card(
            avg_base_demand,
            "Average Demand (Baseline)",
            "{:,.0f} MW",
            "‚ö°",
            demand_change
        )

    with col3:
        avg_price_delta = delta_filtered["delta_price"].mean()
        create_kpi_card(
            avg_price_delta,
            "Price Impact (Shock)",
            "${:+,.2f}/MWh",
            "üìà"
        )

    with col4:
        avg_demand_delta = delta_filtered["delta_demand"].mean()
        create_kpi_card(
            avg_demand_delta,
            "Demand Impact (Shock)",
            "{:+,.0f} MW",
            "üìä"
        )

    # Risk Assessment
    st.markdown("### ‚ö†Ô∏è Risk Assessment")

    col1, col2 = st.columns(2)

    with col1:
        # Price volatility
        price_volatility = base_filtered["forecast_price"].std()
        max_price_spike = delta_filtered["delta_price"].max()

        if max_price_spike > 50:
            risk_level = "üî¥ HIGH"
            risk_color = "error"
        elif max_price_spike > 20:
            risk_level = "üü° MEDIUM"
            risk_color = "warning"
        else:
            risk_level = "üü¢ LOW"
            risk_color = "success"

        st.markdown(f"""
        **Price Risk Level:** {risk_level}
        - Volatility: ${price_volatility:.2f}/MWh
        - Max Spike: ${max_price_spike:+.2f}/MWh
        """)

    with col2:
        # Demand stress
        demand_stress = (shock_filtered["forecast_demand"].max() / base_filtered["forecast_demand"].mean() - 1) * 100

        if demand_stress > 20:
            stress_level = "üî¥ HIGH"
        elif demand_stress > 10:
            stress_level = "üü° MEDIUM"
        else:
            stress_level = "üü¢ LOW"

        st.markdown(f"""
        **Demand Stress:** {stress_level}
        - Peak vs Average: {demand_stress:+.1f}%
        - Max Demand: {shock_filtered["forecast_demand"].max():,.0f} MW
        """)

    # Executive Summary Chart
    st.markdown("### üìä Executive Summary")
    fig = create_executive_summary_chart(base_filtered, shock_filtered)
    st.plotly_chart(fig, use_container_width=True)

    # Financial Impact Calculator
    st.markdown("### üí∞ Financial Impact Calculator")

    col1, col2, col3 = st.columns([1, 1, 2])

    with col1:
        portfolio_size = st.number_input(
            "Portfolio Size (MW)",
            min_value=0.0,
            value=100.0,
            step=10.0,
            help="Enter your total exposure in MW"
        )

    with col2:
        risk_factor = st.selectbox(
            "Risk Multiplier",
            options=[0.5, 1.0, 1.5, 2.0],
            index=1,
            format_func=lambda x: f"{x}x ({'Conservative' if x < 1 else 'Baseline' if x == 1 else 'Aggressive'})"
        )

    with col3:
        # Calculate financial impact
        hours_in_period = len(delta_filtered) * 0.5  # 30-min intervals
        price_impact = delta_filtered["delta_price"].sum() * portfolio_size * 0.5 * risk_factor

        if price_impact > 0:
            impact_color = "üî¥"
            impact_text = "Additional Cost"
        else:
            impact_color = "üü¢"
            impact_text = "Potential Savings"

        st.markdown(f"""
        **{impact_color} Estimated {impact_text}**

        **${abs(price_impact):,.0f}** over {hours_in_period:.0f} hours

        *Based on {portfolio_size:.0f} MW portfolio with {risk_factor}x risk factor*
        """)

    # Quick Actions
    st.markdown("### üéØ Quick Actions")

    col1, col2, col3 = st.columns(3)

    with col1:
        if st.button("üìä View Regional Analysis", use_container_width=True):
            st.switch_page("pages/2_Regional_Analysis.py")

    with col2:
        if st.button("üí• Price Spike Analysis", use_container_width=True):
            st.switch_page("pages/3_Price_and_Spikes.py")

    with col3:
        if st.button("üå§Ô∏è Weather Impact", use_container_width=True):
            st.switch_page("pages/4_Weather_Impact.py")

    # Data freshness info
    st.markdown("---")
    last_update = base_df["datetime"].max()
    st.info(f"üìÖ Data freshness: Forecast generated for period starting {last_update.strftime('%Y-%m-%d %H:%M')} UTC")

    # Footer
    st.markdown("""
    ---
    *Energy Operations Forecast Dashboard | Powered by Advanced Analytics*
    """)

if __name__ == "__main__":
    main()